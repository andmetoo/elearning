# Гайд по гиту
![Git logo](https://git-scm.com/images/logos/downloads/Git-Logo-2Color.png)

## Содержание 
  1. [Введение](#введение)
  2. [Установка](#установка)
  3. [Работа с репозиторием](#работа-с-репозиторием)
  4. [Операции отмены](#операции-отмены)
  5. [Git Flow](#git-flow)

## Введение

**Git** - распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано. ( Если верить Wiki)

Основное отличие Git’а от любой другой СКВ (Subversion и её собратья включительно), это подход Git’а к работе со своими данными. Концептуально, большинство других систем хранят информацию в виде списка изменений в файлах. Эти системы (CVS, Subversion, Perforce, Bazaar и т.д.) представляют информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени.

Git не хранит и не обрабатывает данные таким способом. Вместо этого, подход Git’а к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git’е, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.

Git имеет три основных состояния, в которых могут находиться ваши файлы: зафиксированном (committed), изменённом (modified) и подготовленном (staged). “Зафиксированный” значит, что файл уже сохранён в вашей локальной базе. К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы. Подготовленные файлы — это изменённые файлы, отмеченные для включения в следующий коммит.

Мы подошли к трём основным секциям проекта Git: Git-директория (Git directory), рабочая директория (working directory) и область подготовленных файлов (staging area).

![git area](https://i.imgur.com/YrTtKEX.png)

Git-директория — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git, и это та часть, которая копируется при клонировании репозитория с другого компьютера.

Рабочая директория является снимком версии проекта. Файлы распаковываются из сжатой базы данных в Git-директории и располагаются на диске, для того чтобы их можно было изменять и использовать.

Область подготовленных файлов — это файл, располагающийся в вашей Git-директории, в нём содержится информация о том, какие изменения попадут в следующий коммит. Эту область ещё называют “индекс”, однако называть её stage-область также общепринято.

Базовый подход в работе с Git выглядит так:

Вы изменяете файлы в вашей рабочей директории.

Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.

Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git директорию.

Если определённая версия файла есть в Git-директории, эта версия закоммичена. Если файл изменён и добавлен в индекс, значит, он будет добавлен в следующий коммит. И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается изменённым. 

В ***Git'е*** есть два способа включить изменения из одной ветки в другую: merge (слияние) и rebase (перемещение). ***Merge*** - 'та команда выполняет трёхходовое слияние между двумя последними снимками состояний из веток. При помощи команды ***Rebase*** вы можете взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.
## Установка

Установка Git производится с помощью команд, если macos

```brew install git```

если linux

```apt install git```

## Работа с репозиторием

### Создание нового репозитория и копирование

Создать репозитарий в рабочей директории можно с помощью команды 

```bash
git init
```

после выполнения в папке появится директория ___.git___ - служебная директория git, в которой собственно и находится локальная копия версий кода.

Для копирования репозитория, необходимо использовать команду   
```git clone``` к примеру 

```bash
git clone git@gitlab.fix.ru:epn/elearning.git
```

Если необходимо перенести в заранее известную директорию, можно указать ее после пути к репозитарию 

```bash
git clone git@gitlab.fix.ru:epn/elearning.git mypath
```

### Добавления файлов в локальный индекс изменений

Добавить один файл в индекс изменений 

```bash
git add README
```  

Добавить все файлы с изменениями 

```bash
git add .

## можно и так
git add *

```

Сравнение способов по [ссылке](https://i.stack.imgur.com/OTpcn.png)

Комит изменений 

```bash
git commit -m "Мой самый первый комит"
```

### Отправка и получение изменений

Добавить удаленный сервер 

```bash
git remote add origin ssh://git@github.com/andmetoo/test.git
```

Проверить наличие всех обновлений на удаленном сервере 

```bash
git fetch --all
```

Получить все изменений с удаленного сервера 

```bash
git pull
```

другой вариант

```bash
git pull -r
``` 

где ключ ``` -r ``` означает операцию Rebase , вместо merge в текущую ветку

Отправить изменения на удаленный сервер ```git push``` , либо ``` git push origin dev ``` , если необходимо выбрать удаленный сервер и ветку

### Работа с ветками

Посмотреть список веток ```git branch -v ```

Создать и переключиться на ветку из текущей ветки 

```bash
git checkout -b feature/better_git_branch
```

Переключиться на ветку

```bash
git checkout dev
```

отправить ветку на удалённый сервер 

```bash
git push origin feature/better_git_branching
```

удалить ветку 

```bash
git branch -d feature/better_git_branching
```

### Слияние

Для переключения в dev и слияния ветки в текущую
 
```bash 
git checkout dev && git merge feature/better_git_branching
``` 

Если есть конфликты решаем их и после добавляем в индекс 

```bash 
git add .
```

сравнить ветки 

```bash
git diff dev feature/better_git_branching
```

### Тагаем ветки

Тагнуть ветку 

```bash
git tag -a v1.0.0 -m 'Наш первый релиз'
```

Посмотреть таги 

```bash
git tag
```

Пушим таги 

```bash
git push origin --tags
```

## Stash 

Stas( Скрытие данных )

Посмотреть списком 

```bash
git stash list
```

добавить 

```bash
git stash
```

вернуть из stash 

```bash
git stash apply
```

превратить сокрытые данные в ветку 

```bash
git stash branch stashedbranch
```

## Операции отмены

История коммитов 

```bash
git log
```

Статус репозитория 

```bash
git status
```

Откатить всё до HEAD 

```bash
git reset --hard origin/master
```

откатить только файл 

```bash
git reset HEAD README
```

откатить изменения отдельного файла можно так же с помощью checkout 

```bash
git checkout -- README
```

## Git Flow

### Введение
Наиболее удобным инструментом ведения репозитория является Git Flow, концепция вспомогательного инструмента, построена вокруг модели ветвления [Vincent Driessen](http://nvie.com/posts/a-successful-git-branching-model/).

В соответствии с которой присутствуют основные ветки master и dev, переменные ветки feature, hotfix, support, release.

Разработка ведётся в ветке Dev, все новые улучшения и сущности создаются в ветках Feature, которые попадают в Dev. Поддержка и хотфиксы в Feature  и Support соответственно, откуда попадают в master и dev. Для чего это делается? Для того, что бы срочные фиксы попадали сразу на обе, постоянные ветки. 

Данные напрямую никогда не попадают в ветки dev и master, вместо этого они туда мержатся. 

Важный этап завершения цикла работы с веткой dev является релиз, релиз стартует из ветки Dev в новую ветку release, которая в результате мержится в master, тагается и далее в dev и так же тагается.

### основные команды Git flow

установка 

```bash
brew install git-flow-avh
```
старт 

```bash
git flow init
```

старт фичи 

```bash
git flow feature start my_future_branch 
```

завершение 

```bash
git flow feature finish my_future_branch 
```

релиз 

```bash
git flow release start v1.0.0
```

финиш релиза 

```bash
git flow release finish v1.0.0
git push --tags
```

Далее по аналогии.

Как видим с git flow ,в большинстве случаев, нет необходимости работать с базовыми командами. Это предотвращает появление ошибок, помогает структурировать код, экономит время.

### Литература, доступная для чтения и клиенты Git

Моё личное предпочтение принадлежит консольному клиенту, а так же 

**Клиенты**

[https://git-fork.com](https://git-fork.com), [http://gitup.co](http://gitup.co).

**Литература, которая использовалась при написании документации**
[https://git-scm.com/](https://git-scm.com/book/ru/v2)
[http://danielkummer.github.io/git-flow-cheatsheet/index.ru_RU.html](http://danielkummer.github.io/git-flow-cheatsheet/index.ru_RU.html)
